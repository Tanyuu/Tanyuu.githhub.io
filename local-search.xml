<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>How did I come from?</title>
    <link href="/2022/07/26/How%20did%20I%20come%20from/"/>
    <url>/2022/07/26/How%20did%20I%20come%20from/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2022.07.24</p></blockquote><p>CY老师组织了2022暑假第三次周报，期间RK学长期望与实验室同学来充实友链页；我向学长表示可能会离开CSDN，计划租ECS来建站，之前的友链可能就要改掉了；同时向学长表示关于此计划还要咨询他很多问题，学长则表示：</p><p><img src="https://img-blog.csdnimg.cn/905d71a9510340d08494e293a1a81aa9.png" alt="人和人的体质不能一概而论，学长显然高估了我的能力" /></p><p>于是从21:27搞到了00:25~</p><p>并通过<a href="https://blog.csdn.net/qq_33976344/article/details/123800804">此文章</a>所述办法爬下来了之前CSDN上面的文章，为迁移和备份做好了准备~</p><blockquote><p>2022.07.25</p></blockquote><p>对照着<a href="https://hexo.fluid-dev.com/docs/guide/">Hexo Fluid 配置指南</a>忙活了一晚上，博客终于初具人形~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第八届“图灵杯”NEUQ-ACM程序设计竞赛个人赛 全题解</title>
    <link href="/2021/01/31/%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9DNEUQ-ACM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B8%AA%E4%BA%BA%E8%B5%9B%20%E5%85%A8%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/01/31/%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9DNEUQ-ACM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B8%AA%E4%BA%BA%E8%B5%9B%20%E5%85%A8%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/11746#question">这里</a><br /></p><h1 id="op"><a class="markdownIt-Anchor" href="#op"></a> OP</h1><p>好多大佬哦~</p><h1 id="a-切蛋糕"><a class="markdownIt-Anchor" href="#a-切蛋糕"></a> A 切蛋糕</h1><p>这道题是特判题（SpecialJudge），第一眼没看见，读完题就决定放了。</p><p>由于宽松的步数限制，可以暴力做，即先通过2047次切割把蛋糕切为2048份，即可保证分配时误差值小于 1 / 1024。再找出可行的 c 满足 fabs( c / 2048 - 1 / k ) &lt;= 1 / 1024，即为给每份包装进 c 个 1 / 2<sup>11</sup>。</p><p>注：经测试，蛋糕可以有剩余。</p><p>//标准做法以后再补（flag）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k,two=<span class="hljs-number">1</span>,i,j;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">2048</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>((<span class="hljs-type">double</span>)i/<span class="hljs-number">2048.0</span><span class="hljs-number">-1.0</span>/k)&lt;=<span class="hljs-number">1.0</span>/<span class="hljs-number">1024</span>)<span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> c=i;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-number">2047</span>+k);<span class="hljs-comment">//输出总步数</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=two; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1 %d\n&quot;</span>,i,cou++);<br>        two*=<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=k; j++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2 %d&quot;</span>,c);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=c; i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 11&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="b-小宝的幸运数组"><a class="markdownIt-Anchor" href="#b-小宝的幸运数组"></a> B 小宝的幸运数组</h1><p>用 a[ i ] 表示从第一项加到第 i 项的和，则区间 [ i , j ] 的和为 a[ j ] - a[ i - 1 ] 。</p><p>若区间 [ i , j ] 的和满足能被 k 整除，则有 ( a[ j ] - a[ i - 1 ] ) % k ==0，<br />即 a[ j ] % k == a[ i - 1 ] % k，<br />所以此问题等价为找出 a[ i ] % k 相等的最远距离。<br />O( k n<sup>2</sup> )遍历显然不现实，我们可以对 [ 0 , k - 1 ] 的每一个数存下最前位置和最后位置，再遍历 [ 0 , k - 1 ] 找出左右距离最远的。</p><p><em>求余对四则运算封闭</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100005</span><br> <br>ll a[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-type">int</span> b[<span class="hljs-number">100005</span>]=&#123;<span class="hljs-number">0</span>&#125;,l[<span class="hljs-number">100005</span>]=&#123;<span class="hljs-number">0</span>&#125;,r[<span class="hljs-number">100005</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//b计数，l,r存左右位置</span><br>        <span class="hljs-type">int</span> n,k,i,g,a=<span class="hljs-number">0</span>,m=<span class="hljs-number">0</span>;<br>        cin&gt;&gt;n&gt;&gt;k;<br>        b[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;l[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//数组无元素时</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;g);<br>            a+=g;<br>            a%=k;<br>            <span class="hljs-keyword">if</span>(!b[a])&#123;l[a]=i;b[a]++;&#125;<br>            <span class="hljs-keyword">else</span>&#123;r[a]=i;b[a]++;&#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(b[i]&gt;=<span class="hljs-number">2</span>&amp;&amp;r[i]-l[i]&gt;m)<span class="hljs-comment">//有左有右</span><br>            m=r[i]-l[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(m)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,m);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="c-上进的凡凡"><a class="markdownIt-Anchor" href="#c-上进的凡凡"></a> C 上进的凡凡</h1><p>首先依题意，每个数构成的长度为一的数组均为nice的。</p><p>若某数大于等于前数，则标注成1，否则标记为0，统计每段连续1的长度，对于长度为 n 的连续1，代表了一段长度为 n + 1 的非降数组，此数组中长度大于等于二的子数组有 n * ( n - 1 ) / 2 个。</p><p>累加每一段非降数组的子数组个数，再加上总共的元素个数，即为结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100005</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> n,i,j,c;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">0</span>;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-keyword">for</span>(i=n;i&gt;=<span class="hljs-number">2</span>;i--)<span class="hljs-keyword">if</span>(a[i]&gt;=a[i<span class="hljs-number">-1</span>])a[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> a[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//标注</span><br>    a[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> l,r;<br>    l=<span class="hljs-number">1</span>,r=<span class="hljs-number">1</span>;<br>    ans=n;<span class="hljs-comment">//单元素数组</span><br>    <span class="hljs-keyword">while</span>(l!=n)<br>    &#123;<br>        <span class="hljs-comment">//printf(&quot;%lld %d\n&quot;,ans,r);</span><br>        <span class="hljs-keyword">while</span>((!a[l+<span class="hljs-number">1</span>])&amp;&amp;l&lt;=n)l++;<span class="hljs-comment">//类似于滑窗</span><br>        r=l+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(a[r+<span class="hljs-number">1</span>]&amp;&amp;r&lt;=n)r++;<br>        <span class="hljs-keyword">if</span>(l&lt;=n&amp;&amp;r&lt;=n)&#123;<br>        <span class="hljs-type">int</span> len=r-l+<span class="hljs-number">1</span>;<br>        ans+=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)len*(len<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>        l=r+<span class="hljs-number">1</span>;&#125;<br>        <span class="hljs-keyword">if</span>(l&gt;n)l=n;<span class="hljs-comment">//防溢出</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="d-seek-the-joker-i"><a class="markdownIt-Anchor" href="#d-seek-the-joker-i"></a> D Seek the Joker I</h1><p>巴什博弈</p><p>也可以现推：<br /><em>先手者抽牌+后手者抽牌 为一轮</em></p><p>若保证先手者必赢，则最后一轮开始时需满足桌面有 1 &lt; n &lt;= k + 1 张牌，先手者取 n - 1 张，后手者必输；<br />则倒数第二轮开始时，需满足桌面有 k + 2 &lt; n &lt;= 2 * k + 2 张牌，先手者取至剩 k + 2 张，无论后手者如何取，均可满足先手者必赢的最后一轮条件；<br />同理，倒数第三轮开始时，需满足桌面有 2 * k + 3 &lt; n &lt;= 3 * k + 3 张牌，先手者取至剩  2 * k + 3 张，无论后手者如何取，均可满足先手者必赢的最后一轮条件；</p><p>以此类推，若 n 满足存在正整数 a 使得 ( a - 1 ) * k + a &lt; n &lt;= a * k + a ，则先手者必赢，化简后则等价为 ⌈ n / ( k + 1 ) ⌉ * ( k + 1 ) - k &lt; n。（ ⌈ n / ( k + 1 ) ⌉ 即为 a ）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-type">int</span> n,k;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.0</span>*n/(k+<span class="hljs-number">1</span>))*(k+<span class="hljs-number">1</span>)-k&lt;n)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yo xi no forever!\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ma la se mi no.1!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>补充：也可以说 若 n 满足存在正整数 a 使得 n = ( a - 1 ) * k + a ，等价于 ( n - 1 ) / ( k + 1 )为整数时，先手必输<br />代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-type">int</span> n,k;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>        <span class="hljs-keyword">if</span>((n<span class="hljs-number">-1.0</span>)/(k+<span class="hljs-number">1.0</span>)-(<span class="hljs-type">int</span>)((n<span class="hljs-number">-1.0</span>)/(k+<span class="hljs-number">1.0</span>))&gt;<span class="hljs-number">0.000001</span>)<span class="hljs-comment">//这里如果是1e-4就会WA</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yo xi no forever!\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ma la se mi no.1!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="e-seek-the-joker-ii"><a class="markdownIt-Anchor" href="#e-seek-the-joker-ii"></a> E Seek the Joker II</h1><p><a href="https://blog.csdn.net/qq_41311604/article/details/79980882">威佐夫博弈</a></p><p>这个不太好现推了，走结论吧。</p><p>( a &lt; b )<br />( sqrt(5.0) + 1 ) * ( b - a ) / 2 = a 时，先手必输。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> mysticalConstant = (<span class="hljs-number">1.0</span>+<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5.0</span>))/<span class="hljs-number">2.0</span>;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-type">int</span> n,x;<br>        cin&gt;&gt;n&gt;&gt;x;<br>        <span class="hljs-type">int</span> a=x<span class="hljs-number">-1</span>,b=n-x;<br>        <span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-built_in">swap</span>(a,b);<br>        <span class="hljs-type">int</span> temp = (b-a)*mysticalConstant;<br>        <span class="hljs-keyword">if</span>(temp!=a) cout&lt;&lt;<span class="hljs-string">&quot;yo xi no forever!\n&quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;ma la se mi no.1!\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="f-成绩查询ing"><a class="markdownIt-Anchor" href="#f-成绩查询ing"></a> F 成绩查询ing</h1><p>需要构建两组映射：名字与个人信息，成绩与名字<br />这里多构建了一组：名字与序号（nn），序号与个人信息（stu），成绩与名字（ms）</p><p>成绩对应的名字用set存可以直接按字典序排列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;<span class="hljs-type">int</span>,set&lt;string&gt; &gt;ms;<br>set&lt;string&gt;::iterator it;<br>map&lt;string,<span class="hljs-type">int</span>&gt;nn;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stud</span><br>&#123;<br>    <span class="hljs-type">int</span> gra,sex,num;<br>    <span class="hljs-comment">//string na;</span><br>&#125;stu[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,i;<br>    string ge;<br> <br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        cin&gt;&gt;ge;<br>        nn[ge]=i;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;stu[i].gra,&amp;stu[i].sex,&amp;stu[i].num);<br>        ms[stu[i].gra].<span class="hljs-built_in">insert</span>(ge);<br>    &#125;<br>    <span class="hljs-type">int</span> t,o;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;o);<br>        <span class="hljs-keyword">if</span>(o==<span class="hljs-number">1</span>)<br>        &#123;<br>            cin&gt;&gt;ge;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,<br>                   stu[nn[ge]].gra,stu[nn[ge]].num,stu[nn[ge]].sex);<span class="hljs-comment">//注意顺序</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;o);<br>            <span class="hljs-keyword">if</span>(!ms[o].<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-keyword">for</span>(it=ms[o].<span class="hljs-built_in">begin</span>();it!=ms[o].<span class="hljs-built_in">end</span>();it++)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,(*it).<span class="hljs-built_in">c_str</span>());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="g-贪吃的派蒙"><a class="markdownIt-Anchor" href="#g-贪吃的派蒙"></a> G 贪吃的派蒙</h1><p>先找出派蒙的位置（pmi），计算出派蒙左边的人一轮下来所要吃的最少数量ami和最多数量amx，</p><p>依靠 ami &lt; k &amp;&amp; amx + pmn &gt;= k 判断第一次轮到派蒙时能不能被派蒙吃尽，如果不能，总量减去派蒙吃掉的（pmn）后，每轮ami与amx加上派蒙外所有人的最小值与最大值，再进行比较。amx &gt; k 为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-type">int</span> n,k,pmi,pmn=<span class="hljs-number">0</span>,i,f=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r[<span class="hljs-number">100005</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>        cin&gt;&gt;n&gt;&gt;k;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;r[i]);<br>            <span class="hljs-keyword">if</span>(r[i]&gt;pmn)<br>            &#123;<br>                pmn=r[i];<br>                pmi=i;<br>            &#125;<br>        &#125;<br>        ll ami=pmi<span class="hljs-number">-1</span>,amx=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;pmi; i++)amx+=r[i];<br>        <span class="hljs-keyword">if</span>(ami&lt;k&amp;&amp;amx+pmn&gt;=k)f=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(amx&lt;=k)<br>            &#123;<br>                k-=pmn;<br>                ami+=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//+所有人的最小值</span><br>                <span class="hljs-keyword">for</span>(i=pmi+<span class="hljs-number">1</span>; i&lt;=n; i++)amx+=r[i];<span class="hljs-comment">//+后面人的最大值</span><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;pmi; i++)amx+=r[i];<span class="hljs-comment">//+前面人的最大值</span><br>                <span class="hljs-keyword">if</span>(ami&lt;k&amp;&amp;amx+pmn&gt;=k)<br>                &#123;<br>                    f=<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(f)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="h-数羊"><a class="markdownIt-Anchor" href="#h-数羊"></a> H 数羊</h1><p>打表找规律</p><p>m = 0 时，A( n , 0 ) = n + 2 ;（n = 1 时特判 A( 1, 0 ) = 2 ）<br />m = 1 时，A( n , 1 ) = 2 * n ；<br />m = 2 时，A( n , 2 ) = 2<sup>n</sup>。</p><p>m = 2 时需要用到快速幂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">ll <span class="hljs-title">qm</span><span class="hljs-params">(ll m)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ans=<span class="hljs-number">1</span>,n=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(m)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(m&amp;<span class="hljs-number">1</span>)ans=ans*n%mod;<br>        n=n*n%mod;<br>        m&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans%mod;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll t,n,m;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);<br>        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2\n&quot;</span>);<span class="hljs-comment">//特判</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n+<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-number">2</span>*n);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">qm</span>(n));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="i-买花"><a class="markdownIt-Anchor" href="#i-买花"></a> I 买花</h1><p>若第一天买 a 朵，则第二天有 a * 11(B) 朵，第三天有 a * 111(B) 朵，……，第十五天有 a * 111 1111 1111 1111(B) 朵，则直接遍历[ 11 , 111 , … , 111 1111 1111 1111 ](B)，目标量能否被其中元素整除，若能则可行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k[]=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">15</span>,<span class="hljs-number">31</span>,<span class="hljs-number">63</span>,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">511</span>,<span class="hljs-number">1023</span>,<span class="hljs-number">2047</span>,<span class="hljs-number">4095</span>,<span class="hljs-number">8191</span>,<span class="hljs-number">16383</span>,<span class="hljs-number">32767</span>&#125;;<br>    <span class="hljs-type">int</span> i<span class="hljs-comment">/*0-13*/</span>,n,t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">13</span>;i++)<br>            <span class="hljs-keyword">if</span>(n%k[i]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">14</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;N0\n&quot;</span>);<span class="hljs-comment">//说明没有能整除情况</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YE5\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="j-这是一题简单的模拟"><a class="markdownIt-Anchor" href="#j-这是一题简单的模拟"></a> J 这是一题简单的模拟</h1><p>可以直接用二维数组建图，检验题给数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m,f,t,co,a,mi=<span class="hljs-number">0x7fffffff</span>,i;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> r[<span class="hljs-number">302</span>][<span class="hljs-number">302</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;f,&amp;t,&amp;co);<br>        r[f][t]=co;<br>        r[t][f]=co;<br>    &#125;<br>    cin&gt;&gt;a;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">302</span>]= &#123;<span class="hljs-number">0</span>&#125;,c[<span class="hljs-number">302</span>]= &#123;<span class="hljs-number">0</span>&#125;,g,fl;<span class="hljs-comment">//p存储题给顺序，c检验重复城</span><br>    <span class="hljs-keyword">while</span>(a--)<br>    &#123;<br>        fl=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> p);<br>        <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> c);<br>        cin&gt;&gt;g;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=g; i++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p[i]);<br>            <span class="hljs-keyword">if</span>(!c[p[i]])c[p[i]]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> fl=<span class="hljs-number">0</span>;<span class="hljs-comment">//如有重复城</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(g!=n||!fl)<span class="hljs-keyword">continue</span>;<br>        fl=<span class="hljs-number">1</span>;<br>        f=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cou=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=g&amp;&amp;fl; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(r[f][p[i]])cou+=r[f][p[i]];<br>            <span class="hljs-keyword">else</span> fl=<span class="hljs-number">0</span>;<br>            f=p[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r[f][<span class="hljs-number">0</span>]&amp;&amp;fl)cou+=r[f][<span class="hljs-number">0</span>];<span class="hljs-comment">//注意回家路</span><br>            <span class="hljs-keyword">else</span> fl=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(fl&amp;&amp;cou&lt;=mi)mi=cou;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(mi&lt;<span class="hljs-number">0x7fffffff</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,mi);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="k-黑洞密码"><a class="markdownIt-Anchor" href="#k-黑洞密码"></a> K 黑洞密码</h1><p>字符串处理，注意好对26溢出的处理即可。</p><p>注：对于二维数组 a[ 4 ][ 4 ] ，a[ 0 ][ 5 ] 即代表 a[ 1 ][ 0 ]，这个在这里很好用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>&#125;,in=<span class="hljs-number">0</span>,ch=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>,j;<br>    <span class="hljs-type">char</span> c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>],g;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">32</span>;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;g);<br>        <span class="hljs-keyword">if</span>(g&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;g&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)a[<span class="hljs-number">0</span>][in++]=g-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span> c[<span class="hljs-number">0</span>][ch++]=g;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">3</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">3</span>;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(c[i][j]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;c[i][j]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(c[i][j]+a[i][j]&gt;<span class="hljs-string">&#x27;Z&#x27;</span>)c[i][j]=<span class="hljs-string">&#x27;a&#x27;</span>+c[i][j]+a[i][j]-<span class="hljs-string">&#x27;Z&#x27;</span>;<br>                <span class="hljs-keyword">else</span> c[i][j]+=a[i][j];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(c[i][j]+a[i][j]&gt;<span class="hljs-string">&#x27;z&#x27;</span>)c[i][j]=<span class="hljs-string">&#x27;A&#x27;</span>+c[i][j]+a[i][j]-<span class="hljs-string">&#x27;z&#x27;</span>;<br>                <span class="hljs-keyword">else</span> c[i][j]+=a[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">3</span>;j&gt;=<span class="hljs-number">0</span>;j--)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,c[i][j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="l-建立火车站"><a class="markdownIt-Anchor" href="#l-建立火车站"></a> L 建立火车站</h1><p>二分，对于长度，端点值及其右侧均为可行解，故向左取整。</p><p>注：存在 k = 0 的测试组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a[<span class="hljs-number">100005</span>];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n,k,i;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> l=<span class="hljs-number">1</span>,r=a[n]-a[<span class="hljs-number">1</span>]+<span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)<br>    &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> cou=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=n; i++)<br>        &#123;<br>            <span class="hljs-comment">//if(a[i]-a[i-1]&gt;=mid)</span><br>            &#123;<br>                cou+=(a[i]-a[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>)/mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cou&lt;=k)r=mid;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ed"><a class="markdownIt-Anchor" href="#ed"></a> ED</h1><p>做到最后莫划水，打表有惊喜。</p><p>打表天下第一！</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>比赛与题集</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加分二叉树-DP</title>
    <link href="/2021/01/29/%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-DP/"/>
    <url>/2021/01/29/%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-DP/</url>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://www.acwing.com/problem/content/description/481/">Acwing 479-加分二叉树</a>&amp;<a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=353">NEFU OJ-353 加分二叉树</a><br />NEFU OJ题源为多组输入，代码为此oj ac代码</p><blockquote><p>题目描述</p><blockquote><p>设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。<br />每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：     <br />subtree的左子树的加分 × subtree的右子树的加分 ＋ subtree的根的分数 <br />若某个子树为空，规定其加分为1。叶子的加分就是叶节点本身的分数，不考虑它的空子树。<br />试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。<br />要求输出： <br />（1）tree的最高加分 <br />（2）tree的前序遍历</p></blockquote></blockquote><blockquote><p>输入描述</p><blockquote><p>第1行：一个整数n，为节点个数（n&lt;30） 。<br />第2行：n个用空格隔开的整数，为每个节点的分数（0&lt;分数&lt;100）。</p></blockquote></blockquote><blockquote><p>输出描述</p><blockquote><p>第1行：一个整数，为最高加分（结果不会超过int范围）。     <br />第2行：n个用空格隔开的整数，为该树的前序遍历。如果存在多种方案，则输出字典序最小的方案。</p></blockquote></blockquote><blockquote><p>输入样例</p><blockquote><p>5<br />5 7 1 2 10</p></blockquote></blockquote><blockquote><p>输出样例</p><blockquote><p>145<br />3 1 2 4 5</p></blockquote></blockquote><h2 id="op"><a class="markdownIt-Anchor" href="#op"></a> OP</h2><p>y总yyds</p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>首先明确分数计算方式，对于一般的树而言，分数=左树*右树+根分数<br />如果左树或右树为空，且不均为空，则空树分数视为1；<br />若左右数均空，则空树分数均视为0，此时分数则仅为根分数。</p><p>这道题采用从叶子向根的DP过程，建立 d[ i ][ j ] 表示 [ i , j ] 区间内所有元素构成分数最大的数的分数值。限定该区间的长度，在 [ 1 , n ] 区间从短到长进行DP。</p><p>具体的DP过程：<br />在区间长度为len，左端点 i ，右端点 j = i + len - 1 时，以 k 为区间树的根，d[ i ] [ j ] = max( d[ i ][ k - 1 ] * d[ k + 1 ][ j ] + a[ k ] )。</p><p>接下来进行特判：<br />如果len==1，即 i == j 时，左右子树均为空，d[ i ][ j ] = a[ i ]；<br />如果 k == i，即仅左子树为空，左子树分值为 1；<br />如果 k == j，仅右子树为空同理。</p><p>接下来处理输出要求：<br />因为要求是前序遍历，故遍历 k 时从左到右即可满足条件，即所有可行解中最小 k。并记录区间树的根节点，输出时按根节点分为两树分别递归即可。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">30</span>],f[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>],d[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>]= &#123;<span class="hljs-number">0</span>&#125;,n,i,j,k,len;<br><span class="hljs-comment">//a存储节点分数，f存储[i,j]区间树最大分数值，d存储[i,j]区间树最大分数值时的序号最小根（输出用）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span><span class="hljs-comment">//递归输出</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//结束条件不是i==j</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,f[l][r]);<br>    <span class="hljs-built_in">dfs</span>(l, f[l][r] - <span class="hljs-number">1</span>), <span class="hljs-built_in">dfs</span>(f[l][r] + <span class="hljs-number">1</span>, r);<span class="hljs-comment">//以区间树的根节点为界分成两个区间</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> d);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        <span class="hljs-keyword">for</span>(len=<span class="hljs-number">1</span>; len&lt;=n; len++)<span class="hljs-comment">//遍历合法区间长</span><br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n-len+<span class="hljs-number">1</span>; i++)<span class="hljs-comment">//遍历合法左端点</span><br>            &#123;<br>                j=i+len<span class="hljs-number">-1</span>;<span class="hljs-comment">//计算对应区间长和左端点的右端点</span><br>                <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>)f[i][j]=i,d[i][j]=a[i];<span class="hljs-comment">//特判叶子</span><br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">for</span>(k=i; k&lt;=j; k++)<span class="hljs-comment">//遍历合法根</span><br>                    &#123;<br>                        <span class="hljs-type">int</span> lef=(k==i)?<span class="hljs-number">1</span>:d[i][k<span class="hljs-number">-1</span>];<span class="hljs-comment">//定义左子树分数</span><br>                        <span class="hljs-type">int</span> rig=(k==j)?<span class="hljs-number">1</span>:d[k+<span class="hljs-number">1</span>][j];<span class="hljs-comment">//定义右子树分数</span><br>                        <span class="hljs-type">int</span> ans=a[k]+lef*rig;<span class="hljs-comment">//计算以k为根的区间树分数</span><br>                        <span class="hljs-keyword">if</span>(ans&gt;d[i][j])d[i][j]=ans,f[i][j]=k;<span class="hljs-comment">//与历史值比较（如果是&gt;=，就不是字典序最小答案了）</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,d[<span class="hljs-number">1</span>][n]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,f[<span class="hljs-number">1</span>][n]);<span class="hljs-comment">//此行及下行如果不担心PE的话可以直接用dfs(1,n)代替</span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,f[<span class="hljs-number">1</span>][n] - <span class="hljs-number">1</span>),<span class="hljs-built_in">dfs</span>(f[<span class="hljs-number">1</span>][n] + <span class="hljs-number">1</span>, n);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="ed"><a class="markdownIt-Anchor" href="#ed"></a> ED</h2><p>\</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>DP与贪心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于 硬币购物 一题的思路+难点分析+代码 （DP + 容斥）</title>
    <link href="/2021/01/27/%E5%85%B3%E4%BA%8E%20%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9%20%E4%B8%80%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF+%E9%9A%BE%E7%82%B9%E5%88%86%E6%9E%90+%E4%BB%A3%E7%A0%81%20%EF%BC%88DP%20+%20%E5%AE%B9%E6%96%A5%EF%BC%89/"/>
    <url>/2021/01/27/%E5%85%B3%E4%BA%8E%20%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9%20%E4%B8%80%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF+%E9%9A%BE%E7%82%B9%E5%88%86%E6%9E%90+%E4%BB%A3%E7%A0%81%20%EF%BC%88DP%20+%20%E5%AE%B9%E6%96%A5%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>题目来源：/*这个题好经典的，哪里都有*/ <a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=1793">NEFU OJ-1793 硬币购物-容斥</a></p><blockquote><blockquote><p>题目描述</p></blockquote><p>硬币购物一共有4种硬币。面值分别为c1,c2,c3,c4。某人去商店买东西，去了tot次。每次带di枚ci硬币，买si的价值的东西。请问每次有多少种付款方法。</p><blockquote><p>输入描述</p></blockquote><p>第一行 c1,c2,c3,c4,tot 下面tot行 d1,d2,d3,d4,s</p><blockquote><p>输出描述</p></blockquote><p>每次的方法数</p><blockquote><p>输入样例</p></blockquote><p>1 2 5 10 2<br />3 2 3 1 10<br />1000 2 2 2 900</p><blockquote><p>输出样例</p></blockquote><p>4<br />27</p><blockquote><p>提示</p></blockquote><p>数据规模<br />di,s&lt;=100000<br />tot&lt;=1000</p></blockquote><h2 id="op"><a class="markdownIt-Anchor" href="#op"></a> OP</h2><p>这道题我也是研读了好多位其他博主的文章而通过的，感谢各位前辈。</p><p>直接来说，我认为这道题对我的难点有二：<strong>容斥的构造</strong>和<strong>对dp过程数据的处理</strong></p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>首先排除DFS，这个数据量一定TLE。</p><p>这道题中，相同面值硬币的不同枚之间是完全相同的，所以就无法对所有<strong>枚</strong>硬币进行背包。</p><p>我们只好先不关注四种硬币的数量限制，进行dp，之后再用容斥处理不合法的组合。</p><h2 id="难点分析"><a class="markdownIt-Anchor" href="#难点分析"></a> 难点分析</h2><h4 id="容斥的构建"><a class="markdownIt-Anchor" href="#容斥的构建"></a> 容斥的构建</h4><p>如果不了解容斥，可以向下看</p><p>对于不合法的种类，我们可以<strong>有交集地</strong>分为四类：第一种硬币数量不合法、第二种硬币不合法、第三种…、第四种…。（这样方便用代码实现）<br />这四类之间相互有交集，我们如果想计算不合法的总种类数，就需要妥善处理交集。</p><p>以三种硬币为例：（四种同理，三种表示起来更直观）<br /><img src="https://s2.loli.net/2022/08/02/qyhSkpe9YbTjK6D.png" alt="在这里插入图片描述" /><br />我们暂时称左上圆（A,D,G,E）为O1，右上圆（C,D,G,F）为O2，下圆为O3。<br />如果我们要求这个最大封闭图形的面积，可以通过O1+O2+O3-(O1∩O2)-(O1∩O3)-(O2∩O3)+(O1∩O2∩O3)来实现<br />数学上更广泛来说就是<br /><img src="https://s2.loli.net/2022/08/02/2TMrGCjHoytOJg8.png" alt="在这里插入图片描述" /><br /><em>（图源百度）（如果还是不太理解可以移步<a href="https://blog.csdn.net/qq_40564464/article/details/81779439">这里</a>）</em></p><h4 id="对dp过程数据的处理"><a class="markdownIt-Anchor" href="#对dp过程数据的处理"></a> 对dp过程数据的处理</h4><p>所以此时，我们此题的答案即为 无限制的种类数 - 存在1种硬币非法的种类数（4项）  + 存在2种硬币非法的种类数（6项） - 存在3种硬币非法的种类数（4项） + 4种硬币均非法的种类数（1项）。</p><p>接下来我们要找出不同情况的种类数。</p><p>目标金额 s 时，对于第 i 枚硬币，面值为 c[ i ]，数量为 d[ i ]，如果存在 s &gt;= ( d[ i ] + 1 ) * c[ i ]，则一定该种硬币存在非法情况。同理，对于第 i , j 枚硬币，如果存在 s &gt;=  ( d[ i ] + 1 ) * c[ i ] + ( d[ j ] + 1 ) * c[ j ]，则这两种硬币一定同时存在非法情况。</p><p>那么对于具体的非法种类数即为：f[ s - ( d[ i ] + 1 ) * c[ i ] ]，因为 f[ s ] 是建立于 f[ s - ( d[ i ] + 1 ) * c[ i ] ] 之上的，所以说作差之后，便可认为成 从 s - ( d[ i ] + 1 ) * c[ i ] + 1 到 s 的所有方法数，此时，<strong>每一种情况的第 i 种硬币枚数必不超过 d[ i ]</strong> 。</p><p>也就是说， f[ s - ( d[ i ] + 1 ) * c[ i ] ] 中的每一种情况延伸到 f[ s ] 时，必有一种分支情况存在，满足第 i 种硬币的数量为 d[ i ] + 1（<strong>存在性</strong>），同时，绝对没有任一种情况满足第 i 种硬币的数量大于 d[ i ] + 1（因为那样总金额必然大于 s ）（<strong>唯一性</strong>），在 f[ s - ( d[ i ] + 1 ) * c[ i ] ]  中的每种情况的非法延申存在且唯一，所以删去的便是全部的非法情况。</p><p>同理，多个硬币同时非法时，f[ s - ( d[ i ] + 1 ) * c[ i ] - ( d[ j ] + 1 ) * c[ j ] ] 即可。</p><h4 id="附"><a class="markdownIt-Anchor" href="#附"></a> 附</h4><p>最后附一张第一样例的二维dp表，方便大家验算<br /><img src="https://s2.loli.net/2022/08/02/ZlP6zbKvkJtuYd1.png" alt="在这里插入图片描述" /></p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> c[<span class="hljs-number">4</span>],d[<span class="hljs-number">4</span>],s,t,i,j,k;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> f[<span class="hljs-number">100005</span>]=&#123;<span class="hljs-number">1</span>&#125;,ans;<span class="hljs-comment">//需要LL</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c[i]);<span class="hljs-comment">//接收</span><br>        <span class="hljs-keyword">for</span>(j=c[i];j&lt;=<span class="hljs-number">100000</span>;j++)f[j]+=f[j-c[i]];<span class="hljs-comment">//f 预处理</span><br>    &#125;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d[i]);<br>        cin&gt;&gt;s;<br>        ans=f[s];<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//一种不合法</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(s&gt;=(d[i]+<span class="hljs-number">1</span>)*c[i])<br>            ans-=f[s-(d[i]+<span class="hljs-number">1</span>)*c[i]];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//两种不合法</span><br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s&gt;=(d[i]+<span class="hljs-number">1</span>)*c[i]+(d[j]+<span class="hljs-number">1</span>)*c[j])<br>            ans+=f[s-((d[i]+<span class="hljs-number">1</span>)*c[i]+(d[j]+<span class="hljs-number">1</span>)*c[j])];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//三种不合法</span><br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>        <span class="hljs-keyword">for</span>(k=j+<span class="hljs-number">1</span>;k&lt;<span class="hljs-number">4</span>;k++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s&gt;=(d[i]+<span class="hljs-number">1</span>)*c[i]+(d[j]+<span class="hljs-number">1</span>)*c[j]+(d[k]+<span class="hljs-number">1</span>)*c[k])<br>            ans-=f[s-((d[i]+<span class="hljs-number">1</span>)*c[i]+(d[j]+<span class="hljs-number">1</span>)*c[j]+(d[k]+<span class="hljs-number">1</span>)*c[k])];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s&gt;=(d[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>)*c[<span class="hljs-number">0</span>]+(d[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)*c[<span class="hljs-number">1</span>]+(d[<span class="hljs-number">2</span>]+<span class="hljs-number">1</span>)*c[<span class="hljs-number">2</span>]+(d[<span class="hljs-number">3</span>]+<span class="hljs-number">1</span>)*c[<span class="hljs-number">3</span>])<span class="hljs-comment">//四种不合法</span><br>        ans+=f[s-((d[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>)*c[<span class="hljs-number">0</span>]+(d[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)*c[<span class="hljs-number">1</span>]+(d[<span class="hljs-number">2</span>]+<span class="hljs-number">1</span>)*c[<span class="hljs-number">2</span>]+(d[<span class="hljs-number">3</span>]+<span class="hljs-number">1</span>)*c[<span class="hljs-number">3</span>])];<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="ed"><a class="markdownIt-Anchor" href="#ed"></a> ED</h2><p>感觉证明非法延申存在且唯一的部分可能会比较难懂，但是个人认为很重要，题解第一稿中直接略过了证明，感觉很不妥便加回来了，如有疏漏或逻辑问题，烦请提醒。</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>DP与贪心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于 阿华分硬币 一题的思路+注意点+代码（数组分成差最小的两部分）</title>
    <link href="/2021/01/26/%E5%85%B3%E4%BA%8E%20%E9%98%BF%E5%8D%8E%E5%88%86%E7%A1%AC%E5%B8%81%20%E4%B8%80%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF+%E6%B3%A8%E6%84%8F%E7%82%B9+%E4%BB%A3%E7%A0%81%EF%BC%88%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%B7%AE%E6%9C%80%E5%B0%8F%E7%9A%84%E4%B8%A4%E9%83%A8%E5%88%86%EF%BC%89/"/>
    <url>/2021/01/26/%E5%85%B3%E4%BA%8E%20%E9%98%BF%E5%8D%8E%E5%88%86%E7%A1%AC%E5%B8%81%20%E4%B8%80%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF+%E6%B3%A8%E6%84%8F%E7%82%B9+%E4%BB%A3%E7%A0%81%EF%BC%88%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%B7%AE%E6%9C%80%E5%B0%8F%E7%9A%84%E4%B8%A4%E9%83%A8%E5%88%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=1367">NEFU OJ-1367 阿华分硬币</a><br /><img src="https://s2.loli.net/2022/08/02/NlB9GFU74gRZHpD.png" alt="在这里插入图片描述" /></p><h2 id="op"><a class="markdownIt-Anchor" href="#op"></a> OP</h2><p>DP</p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>首先这个数据量，穷举遍历是行不通的，所以计划用dp，类似于0-1背包问题</p><p>对于这个题我们可以如下构造：b[i][j]为在有前 i 枚硬币时，选出不超过 j 的最大金额值。(不需要担心大于or小于总金额一半到问题，因为若能组成大于总金额一半且差值最小的组合，则另一半即为小于总金额一半且差值最小的组合)</p><p><em>接下来的a[i]代表第i枚硬币的面值</em></p><p>那么状态转换就是 b[i][j] = max ( b[i-1][j] , b[i-1][j-a[i]] + a[i] )<br />语言表述就是 有前i每硬币时，选出不超过j的最大总额是 <strong>在没有第i枚硬币时，不超过j的总额最大值</strong> 与 <strong>在没有第i枚硬币时，不超过j-a[i]的总额最大值加上a[i]</strong> 的最大值。</p><p>到此时，这道题理论上（我没试）就可以AC了。</p><h2 id="向一维化简及注意事项"><a class="markdownIt-Anchor" href="#向一维化简及注意事项"></a> 向一维化简及注意事项</h2><p>这道题与<a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=971">NEFU OJ-971 硬币数目</a>（<a href="https://blog.csdn.net/Tan_Yuu/article/details/113064413">之前的文章</a>）&amp;<a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=1717">NEFU OJ-1717 货币系统</a>不同的是，这道题的每一枚硬币都只能用一次。<br />换句话说，对于一维的状态转换方程————b[j] = max ( b[j] , b[j-a[i]] + a[i] )，b[j-a[i]]这一项必须是维护前的。为解决这个问题，不同于前提两题，j我打算从后向前维护，这样就不会出现同一枚硬币被计算多次的情况。</p><p>以样例二为例，如果从前向后维护，则会出现如下情况：</p><table><thead><tr><th>a[i]\b[j]</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>0</td><td>0</td><td>2</td><td>2</td><td>4</td></tr><tr><td><strong>……</strong></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>此时，b[1][4]=4 , 即用了两次二面值硬币，显然是有违题意的。<br />从后向前则为</p><table><thead><tr><th>a[i]\b[j]</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>0</td><td>0</td><td>2</td><td>2</td><td>2</td></tr><tr><td>1</td><td>0</td><td>1</td><td>2</td><td>3</td><td>3</td></tr><tr><td>5</td><td>0</td><td>1</td><td>2</td><td>3</td><td>3</td></tr></tbody></table><p>5本身就已经大于(最大值 / 2 )了，所以不需要处理，落下来即可。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t,i,j;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-type">int</span> n,a[<span class="hljs-number">1003</span>],l,r,del,sum=<span class="hljs-number">0</span>,b[<span class="hljs-number">50004</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);sum+=a[i];&#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(j=sum/<span class="hljs-number">2</span>;j&gt;=a[i];j--)<span class="hljs-comment">//从sum/2开始就够，不需要关心上下取整</span><br>            &#123;<br>                b[j]=<span class="hljs-built_in">max</span>(b[j],b[j-a[i]]+a[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,(<span class="hljs-type">int</span>)(<span class="hljs-number">2</span>*(sum/<span class="hljs-number">2.0</span>-b[sum/<span class="hljs-number">2</span>])));<span class="hljs-comment">//注意保留浮点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ed"><a class="markdownIt-Anchor" href="#ed"></a> ED</h2><p>\</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>DP与贪心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于 硬币数目 的思路+代码</title>
    <link href="/2021/01/23/%E5%85%B3%E4%BA%8E%20%E7%A1%AC%E5%B8%81%E6%95%B0%E7%9B%AE%20%E7%9A%84%E6%80%9D%E8%B7%AF+%E4%BB%A3%E7%A0%81/"/>
    <url>/2021/01/23/%E5%85%B3%E4%BA%8E%20%E7%A1%AC%E5%B8%81%E6%95%B0%E7%9B%AE%20%E7%9A%84%E6%80%9D%E8%B7%AF+%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=971">NEFU OJ-971 硬币数目</a><br /><img src="https://s2.loli.net/2022/08/02/G2J6aDkMOc3eNXU.png" alt="在这里插入图片描述" /></p><h2 id="op"><a class="markdownIt-Anchor" href="#op"></a> OP</h2><p>DP<br />感谢<a href="https://blog.csdn.net/qq_39354847">sl大佬</a>的讲解</p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>面对这个数据量，dfs肯定会爆TLE，所以打算用DP。</p><p>对于一般情况，状态转移也不复杂：<br />在求最小硬币数时，对于第 i 枚硬币，面值为 v [ i ] ，金额为 j 时，f [ i , j ]=min( f [ i - 1 , j ] , f [ i , j - v [ i ] + 1 )<br />最大硬币数则为 f [ i , j ]=max( f [ i - 1 , j ] , f [ i , j - v [ i ] + 1 )<br />通俗来说，求最小硬币数，在如上情况下，就是求<strong>没有此枚硬币时金额 j 的最小硬币数</strong> 与 <strong>用一枚此硬币的情况——在金额 j - v [ i ] 时，再用一枚此硬币</strong>这两种情况的硬币数最小值。最大值同理。</p><p>但是对于起始情况要特殊处理：<br />在求最小值时，将待处理数组的除0外每一位赋为一个足够大值，第0位赋为0。<br />最大值时赋为一个足够小值。</p><p>特殊处理后，如果在dp完成后，金额 j 无法被组成，则金额 j 保留为极值。（经测试，oj中无非法数据，即每个总金额值必定可以由硬币搭配出）</p><p>为方便理解，附手推过程：<br />输入数据：<br />3 7<br />2 4 3<br />以求最小值为例</p><table><thead><tr><th>i \ j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>+∞</td><td>+∞</td><td>+∞</td><td>+∞</td><td>+∞</td><td>+∞</td><td>+∞</td></tr><tr><td>1</td><td>0</td><td>+∞</td><td>1</td><td>+∞</td><td>2</td><td>+∞</td><td>2</td><td>+∞</td></tr><tr><td>2</td><td>0</td><td>+∞</td><td>1</td><td>+∞</td><td>1</td><td>+∞</td><td>2</td><td>+∞</td></tr><tr><td>3</td><td>0</td><td>+∞</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td></tr></tbody></table><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> n,s;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> w[N],dp[N];<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;s)!=EOF)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i]);<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<span class="hljs-comment">//足够大值</span><br>dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=w[i];j&lt;=s;j++)<br>&#123;<br>dp[j]=min(dp[j],dp[j-w[i]]+<span class="hljs-number">1</span>);<br>&#125; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,dp[s]);<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0xcf</span>,<span class="hljs-keyword">sizeof</span> dp);<span class="hljs-comment">//足够小值</span><br>dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=w[i];j&lt;=s;j++)<br>&#123;<br>dp[j]=max(dp[j],dp[j-w[i]]+<span class="hljs-number">1</span>);<br>&#125; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[s]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="ed"><a class="markdownIt-Anchor" href="#ed"></a> ED</h2><p>dp的初值选取一定要妥当~<br />相似题：<a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=1717">NEFU OJ-1717 货币系统</a></p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>DP与贪心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黑龙江农垦科技职业学院喜迎寒假多校联赛2 全题解</title>
    <link href="/2021/01/23/%E9%BB%91%E9%BE%99%E6%B1%9F%E5%86%9C%E5%9E%A6%E7%A7%91%E6%8A%80%E8%81%8C%E4%B8%9A%E5%AD%A6%E9%99%A2%E5%96%9C%E8%BF%8E%E5%AF%92%E5%81%87%E5%A4%9A%E6%A0%A1%E8%81%94%E8%B5%9B2%20%E5%85%A8%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/01/23/%E9%BB%91%E9%BE%99%E6%B1%9F%E5%86%9C%E5%9E%A6%E7%A7%91%E6%8A%80%E8%81%8C%E4%B8%9A%E5%AD%A6%E9%99%A2%E5%96%9C%E8%BF%8E%E5%AF%92%E5%81%87%E5%A4%9A%E6%A0%A1%E8%81%94%E8%B5%9B2%20%E5%85%A8%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/11471#question">这里</a><br /></p><h1 id="op"><a class="markdownIt-Anchor" href="#op"></a> OP</h1><p>比赛原标题：黑龙江农垦科技职业学院喜迎寒假多校联赛2（快乐ak场）<br />//实际上并不快乐</p><h1 id="a-数组截取"><a class="markdownIt-Anchor" href="#a-数组截取"></a> A 数组截取</h1><p>按字符读入之后转换为数字，比scanf快，学到了~<br />然后用滑窗来做//大概</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a[<span class="hljs-number">20000007</span>],k;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> ch = getchar();<br>    <span class="hljs-keyword">for</span>( ; ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> ; ch = getchar());<br>    <span class="hljs-keyword">for</span>( ; ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span> ; ch = getchar()) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + (ch &amp; <span class="hljs-number">15</span>);<br>    <span class="hljs-comment">/*      x10             %16    */</span><span class="hljs-comment">//因为&#x27;0&#x27;是48</span><br>     <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    n = read() , k = read();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++) a[i] = read();<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> i,sum=<span class="hljs-number">0</span>,m=<span class="hljs-number">0</span>,l=<span class="hljs-number">1</span>;<br>    i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i]&gt;k)<br>        &#123;<br>            sum=<span class="hljs-number">0</span>;<br>            l=i+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            sum+=a[i];<br>            <span class="hljs-keyword">if</span>(sum&gt;k)<br>            &#123;<br>                sum-=a[l];<br>                l++;<br>                <span class="hljs-keyword">while</span>(sum&gt;k&amp;&amp;i-l+<span class="hljs-number">1</span>&gt;=m)<br>                &#123;<br>                    sum-=a[l];<br>                    l++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum==k)<br>            &#123;<br>                m=max(i-l+<span class="hljs-number">1</span>,m);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(m)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,m);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="b-群友们在排列数字"><a class="markdownIt-Anchor" href="#b-群友们在排列数字"></a> B 群友们在排列数字</h1><p>深搜吧，每一层对应0~n-1的每个数，记得恢复现场。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a[<span class="hljs-number">11</span>]=&#123;<span class="hljs-number">0</span>&#125;,n,k,sum,ten=<span class="hljs-number">1</span>,cou=<span class="hljs-number">0</span>,<span class="hljs-comment">//a[i]表示第i位是否被占</span><br>b[<span class="hljs-number">11</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">100000</span>,<span class="hljs-number">1000000</span>,<span class="hljs-number">10000000</span>,<span class="hljs-number">100000000</span>,<span class="hljs-number">1000000000</span>&#125;;<br><span class="hljs-comment">//防止pow超时</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(num==n)<span class="hljs-comment">//收束</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(sum%k==<span class="hljs-number">0</span>)cou++;<br>        <span class="hljs-comment">//printf(&quot;*%d\n&quot;,sum);</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>)<br>            &#123;<br>                a[i]=<span class="hljs-number">1</span>;<br>                sum+=b[i]*num;<br>                dfs(num+<span class="hljs-number">1</span>);<br>                sum-=b[i]*num;<span class="hljs-comment">//恢复现场</span><br>                a[i]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    dfs(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(cou)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,cou);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="c-gg查成绩"><a class="markdownIt-Anchor" href="#c-gg查成绩"></a> C gg查成绩</h1><p>区间和~<br />第 k 位存下1~ k 的和，求[ i , j ]时输出 a[ j ] - a[ i - 1 ]就好了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a[<span class="hljs-number">1000006</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> n,m,i,j;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        a[i]+=a[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;i,&amp;j);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a[j]-a[i<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="d-issue与lifehappy给学生分组"><a class="markdownIt-Anchor" href="#d-issue与lifehappy给学生分组"></a> D issue与lifehappy给学生分组</h1><p>中心是二分<br />类似题可以参考：<a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=1211">NEFU OJ-1211 卖古董</a>和<a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=1708">NEFU OJ-1708 书的复制</a></p><p>注意二分的临界和取整！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> a[<span class="hljs-number">1000006</span>];<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> l=<span class="hljs-number">1e11</span>,r=<span class="hljs-number">1e19</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-comment">//printf(&quot;%d\n&quot;,n);</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%llu&quot;</span>,&amp;a[i]);<br>        <span class="hljs-keyword">if</span>(a[i]&lt;l)l=a[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(l&lt;r)<br>    &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> team=<span class="hljs-number">1</span>,num=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num+a[i]&lt;=mid)<br>                num+=a[i];<br>            <span class="hljs-keyword">else</span> team++,num=a[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(team&lt;=m)r=mid;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//printf(&quot;%u %u\n&quot;,mid,team);</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="e-删删删越小越好"><a class="markdownIt-Anchor" href="#e-删删删越小越好"></a> E 删删删越小越好</h1><p>因为总位数是固定的，已知删去位数即已知剩余位数，在原数中有序找到剩余位数个 数，并使最小就好了。使其最小就是对于每一位，在可以寻找的区间内找到最小数。<br />注意寻找区间的范围</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> a[<span class="hljs-number">20000007</span>];<br>    <span class="hljs-type">int</span> n,i,j,pok=<span class="hljs-number">0</span>;<br>    i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;a[i])&amp;&amp;a[i++]!=<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    a[i<span class="hljs-number">-1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-type">int</span> m=<span class="hljs-built_in">strlen</span>(a);<br>    n=m-n;<br>    <span class="hljs-comment">//printf(&quot;%d&quot;,n);</span><br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">char</span> ma=<span class="hljs-string">&#x27;9&#x27;</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> mark=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;l+n&lt;=m<span class="hljs-number">-1</span>&amp;&amp;ma!=<span class="hljs-string">&#x27;0&#x27;</span>;l++)<span class="hljs-comment">//如果找到0，就不需要再找了，没有比0更小的了&amp;l+n&lt;=m-1即为可寻找区间</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[l]&lt;ma)ma=a[l],mark=l;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a[mark]!=<span class="hljs-string">&#x27;0&#x27;</span>)pok=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(pok)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,ma);<br>        l=mark+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!pok)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="f-happy的异或运算"><a class="markdownIt-Anchor" href="#f-happy的异或运算"></a> F happy的异或运算</h1><p>异或可以看成在二进制下进行的不进位加法。<br />若区间右端点为n，则必存在一m满足在有效位数上（不含前导零）m==~n（即按位取反）且m&lt;n。因为n的最高有效位必为1，m的此位即为0，故m&lt;n。<br />两数异或运算后即为111…11。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> g;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;g);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(g)<span class="hljs-comment">//注</span><br>    &#123;<br>        g&gt;&gt;=<span class="hljs-number">1</span>;<br>        i++;<br>    &#125;<br>    i--;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i)<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：这里用for(two=1;two&lt;g;two*=2);会超时</p><h1 id="g-alan"><a class="markdownIt-Anchor" href="#g-alan"></a> G Alan%%%</h1><p>字符串处理，闹心~</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n,i,f,sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//char a[1003];</span><br>    <span class="hljs-built_in">string</span> a;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    getchar();<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br> <br>        getline(<span class="hljs-built_in">cin</span>,a);<br>        <span class="hljs-type">int</span> cou=<span class="hljs-number">0</span>,cou1=<span class="hljs-number">0</span>;<br>        f=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;a[i];i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">&#x27; &#x27;</span>)<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(f==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">&#x27;l&#x27;</span>)f++;<br>                <span class="hljs-keyword">else</span> f=<span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f==<span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">&#x27;a&#x27;</span>)f++;<br>                <span class="hljs-keyword">else</span> f=<span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f==<span class="hljs-number">3</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">&#x27;n&#x27;</span>)cou1=<span class="hljs-number">1</span>,f=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> f=<span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">&#x27;%&#x27;</span>)cou++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">&#x27;A&#x27;</span>)f=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//printf(&quot;%d %d\n&quot;,cou,cou1);</span><br>        sum+=cou*cou1;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;sum;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>%%%</p><h1 id="hi-cg写项目"><a class="markdownIt-Anchor" href="#hi-cg写项目"></a> H&amp;I cg写项目</h1><p>结构体排序，自定义cmp~<br />两题代码一粘就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class"><span class="hljs-title">dataa</span>&#123;</span><br>    <span class="hljs-type">char</span> n[<span class="hljs-number">25</span>],m[<span class="hljs-number">25</span>],x[<span class="hljs-number">25</span>],h[<span class="hljs-number">25</span>];<br>    <span class="hljs-type">int</span> num;<br>&#125;use[<span class="hljs-number">1000000</span>];<br><span class="hljs-type">bool</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(dataa a,dataa b)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(a.n)==<span class="hljs-built_in">strlen</span>(b.n))<br>    &#123;<br>        <span class="hljs-type">int</span> s=<span class="hljs-built_in">strcmp</span>(a.n,b.n);<br>        <span class="hljs-keyword">if</span>(!s)<br>        &#123;<br>            <span class="hljs-keyword">return</span> a.num&lt;b.num;<span class="hljs-comment">//注</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(a.n)&lt;<span class="hljs-built_in">strlen</span>(b.n);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        use[i].num=i;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,use[i].n);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,use[i].m);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,use[i].x);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,use[i].h);<br>    &#125;sort(use+<span class="hljs-number">1</span>,use+n+<span class="hljs-number">1</span>,cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,use[i].n);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,use[i].m);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,use[i].x);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,use[i].h);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：这里写a&lt;b会报错，因为a,b是类似于迭代器。<br />//我怎么会这么想…</p><h1 id="j-比赛开始了清楚姐姐喊了一句签到了签到了"><a class="markdownIt-Anchor" href="#j-比赛开始了清楚姐姐喊了一句签到了签到了"></a> J 比赛开始了清楚姐姐喊了一句:签到了签到了</h1><p>签到了签到了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n,m=<span class="hljs-number">100000</span>,i,j,mark;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;j);<br>        <span class="hljs-keyword">if</span>(j&lt;m)&#123;m=j;mark=i;&#125;<br>    &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,mark);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ed"><a class="markdownIt-Anchor" href="#ed"></a> ED</h1><p>还是…蛮快乐的……</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>比赛与题集</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于 相似的数集 的思路+时间复杂度分析+代码</title>
    <link href="/2021/01/22/%E5%85%B3%E4%BA%8E%20%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%95%B0%E9%9B%86%20%E7%9A%84%E6%80%9D%E8%B7%AF+%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90+%E4%BB%A3%E7%A0%81/"/>
    <url>/2021/01/22/%E5%85%B3%E4%BA%8E%20%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%95%B0%E9%9B%86%20%E7%9A%84%E6%80%9D%E8%B7%AF+%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90+%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最优解法可以直接参考这位学长的<a href="https://blog.csdn.net/csg999/article/details/104381074">文章</a></p></blockquote></blockquote><p>题目来源：<a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=2119">NEFU OJ-2119 相似的数集简单版</a><br />以及<a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=2118">NEFU OJ-??? 相似的数集高级版</a><br />后者链接已补。</p><p>主要区别在高级版数据范围和数据量均大于前者，接下来将以高级版为主。</p><blockquote><blockquote><p>题目描述</p></blockquote><p>给出两个数集，它们的相似程度定义为Nc/Nt*100%。其中，Nc表示两个数集中相等的、两两互不相同的元素个数，而Nt表示两个数集中总共的互不相同的元素个数。请计算任意两个给出数集的相似程度。</p><blockquote><p>输入描述</p></blockquote><p>输入第一行给出一个正整数N（N&lt;=50），是集合的个数。随后N行，每行对应一个集合。每个集合首先给出一个正整数M（M&lt;=10<sup>4</sup>），是集合中元素的个数；然后跟M个[0, 10<sup>9</sup>]区间内的整数。<br />之后一行给出一个正整数K（K&lt;=2000），随后K行，每行对应一对需要计算相似度的集合的编号（集合从1到N编号）。数字间以空格分隔。<br />第二行给出N个数字，第i个数字表示第i道题通过的人数a<sub>i</sub> (0≤a<sub>i</sub>≤M)。</p><blockquote><p>输出描述</p></blockquote><p>输出共K行，每行一个保留2位小数的实数，表示给定两个集合的相似度值。</p><blockquote><p>输入样例</p></blockquote><p>3<br />3 99 87 101<br />4 87 101 5 87<br />7 99 101 18 5 135 18 99<br />2<br />1 2<br />1 3</p><blockquote><p>输出样例</p></blockquote><p>50.00%<br />33.33%</p></blockquote><h1 id="op"><a class="markdownIt-Anchor" href="#op"></a> OP</h1><p>本题大体思路不复杂，主要在如何降低时间复杂度上。</p><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><p>就题干来说，Nc为被询问的两个集合中重复元素的对数，Nt为两个集合中有多少个不同的数。<br />用数学语言来说，Nc为被询问的两个集合的交集元素个数，Nt为并集元素个数。</p><p>所以我们的目标很明确：1.去重；2.交集计数，经测试，oj的测试组中含有重复询问组，所以还有 3.记忆化。<br />对于去重，我们可以用set / 数组+unique / 桶排。</p><p>对于计数，我们可以双指针计重 / 求交集函数 / map模拟桶排查找键值</p><h3 id="去重"><a class="markdownIt-Anchor" href="#去重"></a> 去重</h3><h5 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h5><p>set性质，<a href="https://blog.csdn.net/sevenjoin/article/details/81908754">不多说</a>;</p><h5 id="数组unique"><a class="markdownIt-Anchor" href="#数组unique"></a> 数组+unique</h5><p>数组接收后，sort排序，再用<a href="https://blog.csdn.net/weixin_42488861/article/details/99402591">unique函数</a>完全去重;</p><h5 id="桶排"><a class="markdownIt-Anchor" href="#桶排"></a> 桶排</h5><p>对于10<sup>9</sup>的数量级，开数组是不现实的（简单版范围较小，可以使用），便想用unordered_map模拟桶排（此路后面会被毙）。</p><h3 id="交集计数"><a class="markdownIt-Anchor" href="#交集计数"></a> 交集计数</h3><p><em>下面的时间复杂度都是对于单次询问的，m,n分别为两个数集的长度</em></p><h5 id="plan-a"><a class="markdownIt-Anchor" href="#plan-a"></a> PLAN A</h5><p>来自<a href="https://blog.csdn.net/csg999/article/details/104381074">学长</a>和lpc大佬。<br />时间复杂度O(min(m , n))<br />双指针在排序后的数组中实现交集计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(sp1&lt;arr[s1<span class="hljs-number">-1</span>][<span class="hljs-number">10000</span>]&amp;&amp;sp2&lt;arr[s2<span class="hljs-number">-1</span>][<span class="hljs-number">10000</span>]) <br>&#123;<span class="hljs-comment">//小的元素指针+1，元素相等same+1</span><br><span class="hljs-keyword">if</span>(arr[s1<span class="hljs-number">-1</span>][sp1]&lt;arr[s2<span class="hljs-number">-1</span>][sp2])sp1++;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[s1<span class="hljs-number">-1</span>][sp1]&gt;arr[s2<span class="hljs-number">-1</span>][sp2])sp2++;<br><span class="hljs-keyword">else</span><br>&#123;<br>same++;<br>sp1++;<br>sp2++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法不加记忆化处理也能在时间限制内横着走。</p><p>注：经ph大佬测试，在set中使用迭代器实现这种方法同样会超时，原因目前认为是容器问题。推测map模拟桶排使用这种方法也会超时。</p><h5 id="plan-b"><a class="markdownIt-Anchor" href="#plan-b"></a> PLAN B</h5><p>来自<a href="https://blog.csdn.net/RealKing_sblog">ph大佬</a><br />时间复杂度O(m+n)<br />使用<a href="https://blog.csdn.net/XiaoTong_zZZ/article/details/106172224">取交集函数</a>（<a href="https://blog.csdn.net/wyg1065395142/article/details/51959499">也可以参考这篇文章</a>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"> set_intersection(l[p].begin(),l[p].end(),<br> l[q].begin(),l[q].end(),<br> inserter(s,s.begin()));<br><span class="hljs-type">int</span> cou = s.size();<br></code></pre></td></tr></table></figure><p>注：使用取交集函数时，可以如下图，方便一些<br /><img src="https://s2.loli.net/2022/08/02/TRh17vIQ3m9EKcf.png" alt="在这里插入图片描述" /><img src="https://s2.loli.net/2022/08/02/GFZ4OdA6XEKP2VD.png" alt="在这里插入图片描述" /><br />注2：这种方法时间限制压的很死，需要搭配记忆化才能避免TLE。</p><h5 id="plan-c"><a class="markdownIt-Anchor" href="#plan-c"></a> PLAN C</h5><p>时间复杂度O(m * log n)<br />通过预处理也只能优化到O( min(m , n) * log( max(m , n)))<br />妥妥TLE，map的.find()函数时间复杂度是O(log n)，unorder_map也救不了。（经测试，2119中，unordered_map/<em>252ms</em>/会比map/<em>472ms</em>/快一倍）（2119中，数组桶排则可以压缩至/<em>43ms</em>/）<br />数据来源：<a href="https://blog.csdn.net/weixin_42333573/article/details/98884961">这里</a>和<a href="https://www.cnblogs.com/shangguanpengfei/p/10483347.html">这里</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//要定义迭代器it</span><br> <span class="hljs-keyword">for</span>(it=s[p].begin(); it!=s[p].end(); it++)<br>            <span class="hljs-keyword">if</span>(s[q].find(it-&gt;first)!=s[q].end())<br>            <span class="hljs-comment">//找到即数集q中含有it-&gt;first</span><br>            &#123;<br>                cou++;<br>            &#125;<br></code></pre></td></tr></table></figure><p>使用这种方法时，如果像下片写代码，会存在引用不存在键值的情况，将出现一些问题，详细描述及解决方法可以参照<a href="https://blog.csdn.net/qq_39354847/article/details/111087774">这篇文章</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(it=s[p].begin();it!=s[p].end();it++)<br>           <span class="hljs-keyword">if</span>(s[q][it-&gt;first])cou++;<br></code></pre></td></tr></table></figure><p>即某些在p数集中存在的键值在q中不存在，但在q中被引用。<br />注：下片的时间复杂度或许小一些？</p><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><p>①数组+unique去重，双指针交集计数；/<em>2119-72ms</em>/</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">50</span>][<span class="hljs-number">10001</span>]; <br><span class="hljs-type">double</span> ans[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>]=&#123;<span class="hljs-number">0</span>&#125;,r; <span class="hljs-comment">//记录查询</span><br><span class="hljs-type">int</span> n,num,s1,s2,same,tmp,sp1,sp2;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;arr[i][<span class="hljs-number">10000</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arr[i][<span class="hljs-number">10000</span>];j++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;arr[i][j]);<br>&#125;<br>sort(arr[i],arr[i]+arr[i][<span class="hljs-number">10000</span>]); <br>arr[i][<span class="hljs-number">10000</span>]=unique(arr[i],arr[i]+arr[i][<span class="hljs-number">10000</span>])-arr[i]; <span class="hljs-comment">//去重</span><br>&#125;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">while</span>(n--)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;s1,&amp;s2);<br><span class="hljs-keyword">if</span>(ans[s1<span class="hljs-number">-1</span>][s2<span class="hljs-number">-1</span>]!=<span class="hljs-number">0</span>) <br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f%\n&quot;</span>,ans[s1<span class="hljs-number">-1</span>][s2<span class="hljs-number">-1</span>]);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>same=<span class="hljs-number">0</span>;<br>sp1=sp2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(sp1&lt;arr[s1<span class="hljs-number">-1</span>][<span class="hljs-number">10000</span>]&amp;&amp;sp2&lt;arr[s2<span class="hljs-number">-1</span>][<span class="hljs-number">10000</span>]) <br>&#123;<br><span class="hljs-comment">//指针</span><br><span class="hljs-keyword">if</span>(arr[s1<span class="hljs-number">-1</span>][sp1]&lt;arr[s2<span class="hljs-number">-1</span>][sp2])sp1++;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[s1<span class="hljs-number">-1</span>][sp1]&gt;arr[s2<span class="hljs-number">-1</span>][sp2])sp2++;<br><span class="hljs-keyword">else</span><br>&#123;<br>same++;<br>sp1++;<br>sp2++;<br>&#125;<br>&#125;<br>r=same*<span class="hljs-number">100.0</span>/(arr[s1<span class="hljs-number">-1</span>][<span class="hljs-number">10000</span>]+arr[s2<span class="hljs-number">-1</span>][<span class="hljs-number">10000</span>]-same); <span class="hljs-comment">//计算</span><br>ans[s1<span class="hljs-number">-1</span>][s2<span class="hljs-number">-1</span>]=ans[s2<span class="hljs-number">-1</span>][s1<span class="hljs-number">-1</span>]=r;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f%\n&quot;</span>,r);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>②数组，取交集函数；/<em>2119-438ms</em>/</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">set</span>&lt;<span class="hljs-type">int</span>&gt; l[<span class="hljs-number">51</span>];<br>    <span class="hljs-type">double</span> ans[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> n,g,i,m,p,q,cou;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>        <span class="hljs-keyword">while</span>(m--)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;g);<br>            l[i].insert(g);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-type">int</span>&gt;s;<br>        cou=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;p,&amp;q);<br>        <span class="hljs-keyword">if</span>(ans[p<span class="hljs-number">-1</span>][q<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">0.0001</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf%%\n&quot;</span>, ans[p<span class="hljs-number">-1</span>][q<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>        set_intersection(l[p].begin(),l[p].end(),l[q].begin(),l[q].end(),inserter(s,s.begin()));<br>        <span class="hljs-type">int</span> cou = s.size();<br>        ans[p<span class="hljs-number">-1</span>][q<span class="hljs-number">-1</span>]=ans[q<span class="hljs-number">-1</span>][p<span class="hljs-number">-1</span>]=cou*<span class="hljs-number">100.0</span>/(l[p].size()+l[q].size()-cou);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf%%\n&quot;</span>, ans[p<span class="hljs-number">-1</span>][q<span class="hljs-number">-1</span>]);&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>③被TLE毙掉的：unordered_map模拟桶排，查找键值。/<em>2119-252ms</em>/</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">51</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">double</span> ans[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">bool</span>&gt; s[<span class="hljs-number">51</span>];<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">bool</span>&gt;::iterator it;<br>    <span class="hljs-type">int</span> n,g,i,m,p,q,cou;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>        a[i]=m;<br>        <span class="hljs-keyword">while</span>(m--)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;g);<br>            <span class="hljs-keyword">if</span>(!s[i][g])s[i][g]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> a[i]--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        cou=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;p,&amp;q);<br>        <span class="hljs-keyword">if</span>(ans[p<span class="hljs-number">-1</span>][q<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">0.0001</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf%%\n&quot;</span>, ans[p<span class="hljs-number">-1</span>][q<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(a[p]&gt;a[q])swap(p,q);<br>        <span class="hljs-keyword">for</span>(it=s[p].begin(); it!=s[p].end(); it++)<br>            <span class="hljs-keyword">if</span>(s[q].find(it-&gt;first)!=s[q].end())<br>            &#123;<br>                cou++;<br>            &#125;<br>            ans[p<span class="hljs-number">-1</span>][q<span class="hljs-number">-1</span>]=ans[q<span class="hljs-number">-1</span>][p<span class="hljs-number">-1</span>]=cou*<span class="hljs-number">100.0</span>/(a[p]+a[q]-cou);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf%%\n&quot;</span>, ans[p<span class="hljs-number">-1</span>][q<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>②慢于③的可能原因的2119数据量太小<br />①慢于数组桶排的原因可能是①的实际运行时间是2*min(m , n)，桶排的实际运行时间取决于数据范围。</p><h1 id="ed"><a class="markdownIt-Anchor" href="#ed"></a> ED</h1><p>这两道题我一共submit 58次！！！<br />AC率不用要了555。</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>四点共圆的判定</title>
    <link href="/2021/01/18/%E5%9B%9B%E7%82%B9%E5%85%B1%E5%9C%86%E7%9A%84%E5%88%A4%E5%AE%9A/"/>
    <url>/2021/01/18/%E5%9B%9B%E7%82%B9%E5%85%B1%E5%9C%86%E7%9A%84%E5%88%A4%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=2248">NEFU OJ-2248</a>&amp;<br /><a href="https://ac.nowcoder.com/acm/contest/9707">湖南大学2020届ACM新生赛(同步赛) F</a></p><h2 id="op"><a class="markdownIt-Anchor" href="#op"></a> OP</h2><p>此题不难，只不过推导比较闹心，多推几遍就AC了。</p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>判断四点共圆，特殊方法是对角互补，但是由于此题中未强调顺序，判断对角有一定的难度。故采用更通用的方法：</p><p>设四点为A，B，C，D（顺序无关）<br />先任取三点A、B、C<br />当A、B、C 不共线时：</p><p>\首先通过AB、AC的中垂线交点确定距此三点距离相等的点，并假定其为圆心；<br />\再计算半径，并与第四点到假定圆心的距离进行比较，从而判断第四点是否共圆。</p><p>当A、B、C 共线时：</p><p>\显然没有圆满足与一条直线有三个交点，故四点不共圆。<br /><img src="https://s2.loli.net/2022/08/02/XOziP1H9W6R2MQg.png" alt="在这里插入图片描述" /></p><p>具体实现上，可以通过中学的平面几何知识构造中垂线方程，解假定圆心，只不过推导较为繁琐。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">double</span> x[<span class="hljs-number">4</span>],y[<span class="hljs-number">4</span>],xo,yo,down;<br>    <span class="hljs-type">int</span> t,i,j;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)<span class="hljs-built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];<br>        down=(x[<span class="hljs-number">2</span>]-x[<span class="hljs-number">0</span>])*(y[<span class="hljs-number">0</span>]-y[<span class="hljs-number">1</span>])-(x[<span class="hljs-number">1</span>]-x[<span class="hljs-number">0</span>])*(y[<span class="hljs-number">0</span>]-y[<span class="hljs-number">2</span>]);<br>        down*=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(down)&lt;=<span class="hljs-number">1e-10</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no\n&quot;</span>);<span class="hljs-comment">//判断三点共线</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            xo=(x[<span class="hljs-number">0</span>]*x[<span class="hljs-number">0</span>]-x[<span class="hljs-number">2</span>]*x[<span class="hljs-number">2</span>])*(y[<span class="hljs-number">0</span>]-y[<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>-(x[<span class="hljs-number">0</span>]*x[<span class="hljs-number">0</span>]-x[<span class="hljs-number">1</span>]*x[<span class="hljs-number">1</span>])*(y[<span class="hljs-number">0</span>]-y[<span class="hljs-number">2</span>])/<span class="hljs-number">2</span>+(y[<span class="hljs-number">0</span>]-y[<span class="hljs-number">2</span>])*(y[<span class="hljs-number">0</span>]-y[<span class="hljs-number">1</span>])*(y[<span class="hljs-number">2</span>]-y[<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>;<br>            xo/=down;<br>            yo=(x[<span class="hljs-number">1</span>]-x[<span class="hljs-number">0</span>])/<span class="hljs-number">2</span>*(-(x[<span class="hljs-number">0</span>]*x[<span class="hljs-number">0</span>]-x[<span class="hljs-number">2</span>]*x[<span class="hljs-number">2</span>])-(y[<span class="hljs-number">0</span>]*y[<span class="hljs-number">0</span>]-y[<span class="hljs-number">2</span>]*y[<span class="hljs-number">2</span>]))-(x[<span class="hljs-number">2</span>]-x[<span class="hljs-number">0</span>])/<span class="hljs-number">2</span>*(-(x[<span class="hljs-number">0</span>]*x[<span class="hljs-number">0</span>]-x[<span class="hljs-number">1</span>]*x[<span class="hljs-number">1</span>])-(y[<span class="hljs-number">0</span>]*y[<span class="hljs-number">0</span>]-y[<span class="hljs-number">1</span>]*y[<span class="hljs-number">1</span>]));<br>            yo/=down;<br>            yo*=<span class="hljs-number">-1</span>;<br>            <span class="hljs-comment">//printf(&quot;%lf %lf\n&quot;,xo,yo);</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>((x[<span class="hljs-number">0</span>]-xo)*(x[<span class="hljs-number">0</span>]-xo)+(y[<span class="hljs-number">0</span>]-yo)*(y[<span class="hljs-number">0</span>]-yo)-(x[<span class="hljs-number">3</span>]-xo)*(x[<span class="hljs-number">3</span>]-xo)-(y[<span class="hljs-number">3</span>]-yo)*(y[<span class="hljs-number">3</span>]-yo))&lt;=<span class="hljs-number">1e-10</span>)<br>                 <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ed"><a class="markdownIt-Anchor" href="#ed"></a> ED</h2><p>此种方法也可以拓展为判断n点共圆；</p><h1 id="推-导-时-注-意-正-负-号"><a class="markdownIt-Anchor" href="#推-导-时-注-意-正-负-号"></a> 推 导 时 注 意 正 负 号 ！</h1>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>数论与几何</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于	火车编组的思路+代码</title>
    <link href="/2021/01/02/%E5%85%B3%E4%BA%8E%20%E7%81%AB%E8%BD%A6%E7%BC%96%E7%BB%84%E7%9A%84%E6%80%9D%E8%B7%AF+%E4%BB%A3%E7%A0%81/"/>
    <url>/2021/01/02/%E5%85%B3%E4%BA%8E%20%E7%81%AB%E8%BD%A6%E7%BC%96%E7%BB%84%E7%9A%84%E6%80%9D%E8%B7%AF+%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#op">OP</a></li><li><a href="#%E5%A4%A7%E4%BD%93%E6%80%9D%E8%B7%AF">大体思路</a></li><li><a href="#%E6%9C%89%E5%85%B3%E9%99%90%E5%AE%9A%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%83%B3%E6%B3%95">有关限定条件的想法</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#ed">ED</a></li></ul><br />题目来源：<a href="http://acm.nefu.edu.cn/problemShow.php?problem_id=1628">NEFU OJ 栈-火车编组</a> 详细链接已补<br /><img src="https://s2.loli.net/2022/08/02/eSzPV3bDfWFQH67.png" alt="咕咕咕" /></p><h2 id="op"><a class="markdownIt-Anchor" href="#op"></a> OP</h2><p>oj中没有配图，我就没有 想透 题，最后查到<a href="https://blog.csdn.net/czjl6886/article/details/102537461">这里</a>才完全理解，下面的示意图亦出自该帖。</p><h2 id="大体思路"><a class="markdownIt-Anchor" href="#大体思路"></a> 大体思路</h2><p><img src="https://s2.loli.net/2022/08/02/dgY8GymzcHrRVlP.png" alt="感谢大佬" /><br />以样例为例，题意即为将A端（左至右）1，2，3，4，通过编组站调至B端（左至右）3，2，4，1。</p><p>我们可以将轨道中段视为栈，从A方向入栈，向B方向出栈。</p><p>决定出栈还是继续入栈的判据即为目前栈顶元素与目标车厢编号的大小关系：<br />——如果小于目标车厢编号，则继续从A端入栈；<br />——如果等于，则出栈进行编组；<br />——如果大于，则请看下一个二级目录。</p><p>某车厢出栈编组后，目标车厢编号即变为目标序列的下一元素，直至目标序列被编组完毕。</p><h2 id="有关限定条件的想法"><a class="markdownIt-Anchor" href="#有关限定条件的想法"></a> 有关限定条件的想法</h2><p>无论是在oj中，还是图源帖中，对题目的描述始终没有明确入栈的车厢是否可以出栈至A端，但是就我的判断，题目中不能。</p><p>图源帖中的问题是判断目标序列能否达成，如果能出栈至A端，则不存在非法序列。同理，oj经测试，所有测试组均合法。</p><p>对于图源帖中的问题，如果目前栈顶元素大于目标车厢编号，则可判断该序列非法。若考虑可以出栈至A端，则可以出栈至A端等待再次入栈。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#include &lt;bits/stdc++.<span class="hljs-property">h</span>&gt;<br>using namespace std;<br><br>int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)<br>&#123;<br>    stack&lt;int&gt;ord;<span class="hljs-comment">//ord为A端</span><br>    stack&lt;int&gt;sta;<span class="hljs-comment">//sta为编组用栈</span><br>    int aim[<span class="hljs-number">105</span>],process=<span class="hljs-number">1</span>;<span class="hljs-comment">//aim记录目标序列，</span><br>                     <span class="hljs-comment">//process记录目标车厢编号</span><br>    int n,i;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    cin&gt;&gt;aim[i];<br>    <span class="hljs-keyword">for</span>(i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>    ord.<span class="hljs-title function_">push</span>(i);<br>    <span class="hljs-keyword">while</span>(process!=n+<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!sta.<span class="hljs-title function_">empty</span>()&amp;&amp;sta.<span class="hljs-title function_">top</span>()&gt;aim[process])<br>        &#123;<br>            <span class="hljs-comment">/*ord.push(sta.top());这段注释掉的是出栈至A端</span><br><span class="hljs-comment">            sta.pop();</span><br><span class="hljs-comment">            cout&lt;&lt;&#x27;B&#x27;;*/</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sta.<span class="hljs-title function_">empty</span>()||sta.<span class="hljs-title function_">top</span>()&lt;aim[process])<br>        &#123;<br>            sta.<span class="hljs-title function_">push</span>(ord.<span class="hljs-title function_">top</span>());<br>            ord.<span class="hljs-title function_">pop</span>();<br>            cout&lt;&lt;<span class="hljs-string">&#x27;A&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sta.<span class="hljs-title function_">top</span>()==aim[process])<br>        &#123;<br>            sta.<span class="hljs-title function_">pop</span>();<br>            cout&lt;&lt;<span class="hljs-string">&#x27;B&#x27;</span>;<br>            process++;<span class="hljs-comment">//目标车厢改为下一个</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ed"><a class="markdownIt-Anchor" href="#ed"></a> ED</h2><p>另：对于空栈使用.top会RTE。</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于	Bsq AK ZUCCPC的思路+代码</title>
    <link href="/2020/12/27/%E5%85%B3%E4%BA%8E_Bsq%20AK%20ZUCCPC%E7%9A%84%E6%80%9D%E8%B7%AF+%E4%BB%A3%E7%A0%81/"/>
    <url>/2020/12/27/%E5%85%B3%E4%BA%8E_Bsq%20AK%20ZUCCPC%E7%9A%84%E6%80%9D%E8%B7%AF+%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#op">OP</a></li><li><a href="#%E5%A4%A7%E4%BD%93%E6%80%9D%E8%B7%AF">大体思路</a></li><li><a href="#ac%E4%BB%A3%E7%A0%81">AC代码</a></li><li><a href="#ed">ED</a></li></ul><br />题目来源：<a href="https://ac.nowcoder.com/acm/contest/9934#question">2020年浙大城市学院新生程序设计竞赛（同步赛）-H Bsq AK ZUCCPC</a></p><blockquote><blockquote><p>题目描述</p></blockquote><p>新生赛开赛在即，Kwords打算预测每道题的过题人数，现在他想知道如果按照他预测的过题数据，会有多少人能够AK（全部通过）或爆零（无法通过任何一道题）呢。因为Kwords并不知道榜单实际的过题情况，所以希望你能帮助他预测AK和爆零的人数区间。</p><blockquote><p>输入描述</p></blockquote><p>第一行给出一个正整数T(1≤T≤10)，表示接下来会给出T组测试数据。<br />对于每组测试数据，第一行给出两个正整数N(1≤N≤10<sup>5</sup>)表示新生赛有多少个题目，M(1≤M≤10<sup>9</sup> )表示参赛人数。<br />第二行给出N个数字，第i个数字表示第i道题通过的人数a<sub>i</sub> (0≤a<sub>i</sub>≤M)。</p><blockquote><p>输出描述</p></blockquote><p>对于每组数据，第一行给出两个数字L<sub>1</sub>,R<sub>1</sub>,表示AK的人数在区间[L<sub>1</sub>,R<sub>1</sub>]内，第二行给出两个数字L<sub>2</sub>,R<sub>2</sub>，表示爆零的人数在区间[L<sub>2</sub>,R<sub>2</sub>]内。</p></blockquote><h2 id="op"><a class="markdownIt-Anchor" href="#op"></a> OP</h2><p>感谢<a href="https://blog.csdn.net/RealKing_sblog">rk学长</a>与<a href="https://blog.csdn.net/qq_39354847">sl学长</a>的倾情指导。<br />.</p><h2 id="大体思路"><a class="markdownIt-Anchor" href="#大体思路"></a> 大体思路</h2><p>对于每道题，有a<sub>i</sub>人A掉，有M-a<sub>i</sub>人未A。则对于所有N道题，设A了P=a<sub>1</sub>+a<sub>2</sub>+…+a<sub>n</sub>人次，未A Q=M-a<sub>1</sub>+M-a<sub>2</sub>+…+M-a<sub>n</sub>人次。<br />对于AK左限，我们可以假设所有未A是尽可能由不同人完成的，即L<sub>1</sub>=MAX{M-Q , 0};对于AK右限，我们可以假设A掉AC数最少题的人也A掉了其他所以题，即L<sub>2</sub>=MIN{a<sub>i</sub>}；对于爆零左右限同理，L<sub>1</sub>=MIN{M-P , 0}，L<sub>2</sub>=M-MAX{a<sub>I</sub>} 。</p><p>两个右限可如下例直观解释，N=6，M=20：<br /><img src="https://s2.loli.net/2022/08/02/B4NOspYCz9G3rWF.png" alt="触摸板写字真费劲" /><br />.</p><h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#include &lt;bits/stdc++.<span class="hljs-property">h</span>&gt;<br>typedef long long ll;<br>using namespace std;<br>int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)<br>&#123;<br>    ll t,m,n,i;<br>    <span class="hljs-title function_">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-title function_">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);<br>        ll a[<span class="hljs-number">100005</span>],mi=<span class="hljs-number">1000000000</span>,suf=<span class="hljs-number">0</span>,ma=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        &#123;<br>            <span class="hljs-title function_">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br>            <span class="hljs-keyword">if</span>(a[i]&lt;mi)mi=a[i];<br>            <span class="hljs-keyword">if</span>(a[i]&gt;ma)ma=a[i];<br>            sum+=a[i];<br>            suf+=m-a[i];<br>        &#125;<br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;%lld %lld\n%lld %lld\n&quot;</span>,<br>        ((suf&gt;m)?<span class="hljs-number">0</span>:m-suf),mi,((sum&gt;m)?<span class="hljs-number">0</span>:m-sum),m-ma);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="ed"><a class="markdownIt-Anchor" href="#ed"></a> ED</h2><p>这套题真的太草了（双语）；<br />&amp;我被吊锤；<br />&amp;但我还是喜欢。</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于GPA Involution的思路+解法+代码</title>
    <link href="/2020/12/27/%E5%85%B3%E4%BA%8EGPA%20Involution%E7%9A%84%E6%80%9D%E8%B7%AF+%E8%A7%A3%E6%B3%95+%E4%BB%A3%E7%A0%81/"/>
    <url>/2020/12/27/%E5%85%B3%E4%BA%8EGPA%20Involution%E7%9A%84%E6%80%9D%E8%B7%AF+%E8%A7%A3%E6%B3%95+%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#op">OP</a></li><li><a href="#%E5%A4%A7%E4%BD%93%E6%80%9D%E8%B7%AF">大体思路</a></li><li><a href="#%E5%A7%91%E4%B8%94%E7%AE%97%E6%98%AF%E8%A7%A3%E6%B3%95">（姑且算是）解法</a></li><li><a href="#ac%E4%BB%A3%E7%A0%81">AC代码</a></li><li><a href="#%E4%B8%8D%E5%BD%93%E8%A7%A3%E6%B3%95">不当解法</a></li><li><a href="#ed">ED</a></li></ul><br />题目来源：<a href="https://ac.nowcoder.com/acm/contest/9934#question">2020年浙大城市学院新生程序设计竞赛（同步赛）-K GPA Involution</a></p><h2 id="op"><a class="markdownIt-Anchor" href="#op"></a> OP</h2><p>感谢<a href="https://blog.csdn.net/RealKing_sblog">rk学长</a>与<a href="https://blog.csdn.net/qq_39354847">sl学长</a>的倾情指导。<br />.</p><h2 id="大体思路"><a class="markdownIt-Anchor" href="#大体思路"></a> 大体思路</h2><p>由题意，对最终结果产生影响的只有所选A/B中最大的扣分值，所以题目的顺序对结果无关，由此我们可以按某一选项分值进行排序（接下来用A，升序），再进行处理。</p><p>首先我们先保证由A扣掉的分值尽可能小，即在排序后的某一题之前的所有题全部选A，即由A扣掉的分数为该题的A选项的扣分值。其余题（该题之后的所有题）均选择B，由B扣掉的分数即为右侧所有B扣分值的最大值。</p><p>.</p><h2 id="姑且算是解法"><a class="markdownIt-Anchor" href="#姑且算是解法"></a> （姑且算是）解法</h2><p>排序之后，设题目为1,2,…,n；A选项扣分为A1,A2,…,An；B选项扣分为B1,B2,…,Bn。则如果第m(m=<em>0</em>,1,2,…,n,<em>n+1</em>)题及之前均选A，则扣分值为A<sub>m</sub>+MIN{b<sub>m+1</sub>,…,b<sub>n</sub>}，对m遍历求最小值即可。</p><p><strong>对于MIN{b<sub>m+1</sub>,…,b<sub>n</sub>} ，不需要在处理每个m时分别求出，</strong><br />可以通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">p[n+<span class="hljs-number">1</span>].<span class="hljs-property">b</span>=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span>(i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">1</span>;i--)<br>   &#123;<br>       p[i].<span class="hljs-property">b</span>=(p[i].<span class="hljs-property">b</span>&gt;p[i+<span class="hljs-number">1</span>].<span class="hljs-property">b</span>) ? p[i].<span class="hljs-property">b</span> : p[i+<span class="hljs-number">1</span>].<span class="hljs-property">b</span> ;<br>   &#125;<br></code></pre></td></tr></table></figure><p>直接将B<sub>m+1</sub>存为B<sub>m</sub>之后（不含B<sub>m</sub>）的最大值。<br /><em>此种处理方法也在<a href="">库特的鸽鸽们</a>（以后补链）一题中，求在接收最后一次操作二后，所接受操作一的最大数值。</em></p><p><strong>进一步优化：</strong><br />假设排序后，B<sub>n</sub>最大值在第x题。则在x题之前，随m的增加，由B造成的扣分值不变，均为B<sub>n</sub>的最大值，而由A造成的扣分值增长。故只需要遍历m(m=0,x,x+1,…,n,n+1)。</p><h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#include &lt;bits/stdc++.<span class="hljs-property">h</span>&gt;<br>typedef long long ll;<br>using namespace std;<br>struct poi&#123;<br>ll a,b;<br>&#125;p[<span class="hljs-number">200005</span>];<br>bool <span class="hljs-title function_">cmp</span>(<span class="hljs-params">poi a,poi b</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-property">a</span>&lt;b.<span class="hljs-property">a</span>;<br>&#125;<br>int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)<br>&#123;<br><br>    ll n,i,mp,ma=<span class="hljs-number">0</span>;<br>    <span class="hljs-title function_">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-title function_">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;p[i].<span class="hljs-property">a</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-title function_">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;p[i].<span class="hljs-property">b</span>);<br>    <span class="hljs-title function_">sort</span>(p+<span class="hljs-number">1</span>,p+<span class="hljs-number">1</span>+n,cmp);<span class="hljs-comment">//排序</span><br>    p[n+<span class="hljs-number">1</span>].<span class="hljs-property">b</span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">1</span>;i--)<br>    &#123;<br>        p[i].<span class="hljs-property">b</span>=(p[i].<span class="hljs-property">b</span>&gt;p[i+<span class="hljs-number">1</span>].<span class="hljs-property">b</span>)?p[i].<span class="hljs-property">b</span>:p[i+<span class="hljs-number">1</span>].<span class="hljs-property">b</span>;<br>    &#125;<br>    mp=p[<span class="hljs-number">1</span>].<span class="hljs-property">b</span>;<span class="hljs-comment">//m初始值为m=0（此时总扣分值仅为B的最大值）</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;p[i].<span class="hljs-property">b</span>!=mp;i++);<span class="hljs-comment">//找到x</span><br>    <span class="hljs-keyword">for</span>(;i&lt;=n;i++)<span class="hljs-comment">//从x之后</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(p[i].<span class="hljs-property">a</span>+p[i+<span class="hljs-number">1</span>].<span class="hljs-property">b</span>&lt;mp)mp=p[i].<span class="hljs-property">a</span>+p[i+<span class="hljs-number">1</span>].<span class="hljs-property">b</span>;<br>    &#125;<br>    <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,(mp&gt;p[n].<span class="hljs-property">a</span>)?p[n].<span class="hljs-property">a</span>:mp);<span class="hljs-comment">//m=n+1时与之前的比较</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不当解法"><a class="markdownIt-Anchor" href="#不当解法"></a> 不当解法</h2><p>#1<br />一种朴素的想法：对于每一题，比较A与B的扣分值，将较小值加入对应选项的组，最后在各组比较该组最大值，并将两组最大值求和。<br />对于该测试组</p><blockquote><p>5<br />1 1 4 5 9<br />1 1 8 4 5</p></blockquote><p>正确算法应该返回8（全选B）<br />而#1算法会返回9（1，2，3为A；4，5为B）</p><p>#2<br />一种类似DP的想法：<br />顺序处理每一题，选择此题选A/B对总扣分造成最小增量的情况。</p><blockquote><p>5<br />1 1 4 5 9<br />1 1 8 4 5</p></blockquote><p>此算法会返回9（1，2均A）或10（1，2均B）<br />*<em>对于对结果影响相等的题目，在当次处理中不会造成差异，但是对以后的处理，会有后效性</em>(来自sl）</p><h2 id="ed"><a class="markdownIt-Anchor" href="#ed"></a> ED</h2><p>这套题真的太草了（双语）；<br />&amp;我被吊锤；<br />&amp;但我还是喜欢。</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
